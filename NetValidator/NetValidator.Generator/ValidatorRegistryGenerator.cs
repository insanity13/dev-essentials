using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace NetValidator.Generator
{
    [Generator]
    public class ValidatorRegistryGenerator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new ValidatorSyntaxReceiver());
        }

        public void Execute(GeneratorExecutionContext context)
        {
            if (!(context.SyntaxReceiver is ValidatorSyntaxReceiver receiver))
                return;

            var compilation = context.Compilation;
            var validatorClasses = GetValidatorClasses(receiver, compilation);

            if (!validatorClasses.Any())
                return;

            var validatorsByType = GetValidatorsByType(validatorClasses);

            GenerateAddValidators(context, validatorsByType);
        }

        private static IReadOnlyCollection<IGrouping<ITypeSymbol, (INamedTypeSymbol ValidatorType, ITypeSymbol ValidatedType)>> GetValidatorsByType(IEnumerable<INamedTypeSymbol> validatorClasses)
        {
            return validatorClasses
                .SelectMany(v => v.AllInterfaces.Where(i => i != null && i.IsGenericType && i.ConstructedFrom?.ToDisplayString() == "NetValidator.Core.IValidator<T>")
                    .Select(i => (ValidatorType: v, ValidatedType: i.TypeArguments.FirstOrDefault())))
                .Where(x => x.ValidatedType != null)
                .GroupBy(x => x.ValidatedType)
                .ToList();
        }
      

        private static void GenerateAddValidators(GeneratorExecutionContext context, IReadOnlyCollection<IGrouping<ITypeSymbol, (INamedTypeSymbol ValidatorType, ITypeSymbol ValidatedType)>> validatorsByType)
        {
            var validatorRegistryInitializer = new StringBuilder();
            validatorRegistryInitializer.AppendLine(@"// <auto-generated/>
using System;
using NetValidator.Core;
using Microsoft.Extensions.DependencyInjection;

namespace NetValidator.Core
{
    public static class DependencyInjection
    {
        public static IServiceCollection AddValidators(this IServiceCollection services)
        {");

            foreach (var group in validatorsByType)
            {
                var validatedType = group.Key;
                foreach (var validator in group)
                {
                    validatorRegistryInitializer.AppendLine($@"            services.AddScoped<NetValidator.Core.IValidator<{validatedType}>, {validator.ValidatorType}>();");
                }
            }         

            validatorRegistryInitializer.AppendLine("return services;");
            validatorRegistryInitializer.AppendLine(@"        }
    }
}");

            context.AddSource("AddValidatorsExtensions.g.cs", SourceText.From(validatorRegistryInitializer.ToString(), Encoding.UTF8));
        }

        private static System.Collections.Generic.IEnumerable<INamedTypeSymbol> GetValidatorClasses(ValidatorSyntaxReceiver receiver, Compilation compilation)
        {

            // Get all classes that implement IValidator<T> with null checks
            return receiver.ValidatorCandidates
                .Select(c =>
                {
                    var model = compilation.GetSemanticModel(c.SyntaxTree);
                    return model?.GetDeclaredSymbol(c) as INamedTypeSymbol;
                })
                .Where(s => s != null)
                .Where(s => s.AllInterfaces.Any(i =>
                    i != null &&
                    i.IsGenericType &&
                    i.ConstructedFrom?.ToDisplayString() == "NetValidator.Core.IValidator<T>"));
        }

    }
}
